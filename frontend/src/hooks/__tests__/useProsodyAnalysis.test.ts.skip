import { renderHook, act, waitFor } from '@testing-library/react'
import { useProsodyAnalysis, useSectionAnalysis, useLineAnalysis, useProsodySettings } from '../useProsodyAnalysis'
import * as prosodyUtils from '../../utils/prosodyAnalysis'

// Mock lodash debounce to make tests synchronous
jest.mock('lodash', () => ({
  debounce: (fn: (...args: unknown[]) => unknown) => {
    const debounced = (...args: unknown[]) => fn(...args)
    debounced.cancel = jest.fn()
    return debounced
  },
}))

// Mock prosody analysis functions
jest.mock('../../utils/prosodyAnalysis', () => ({
  analyzeProsody: jest.fn(),
}))

describe('useProsodyAnalysis', () => {
  const mockAnalysisResult = {
    lines: [
      {
        text: 'Test line',
        lineNumber: 1,
        syllableCount: 2,
        endingType: 'stable' as const,
        endingWord: 'line',
        rhymeSound: 'ine',
      },
    ],
    sections: [
      {
        name: 'Verse',
        lineCount: 1,
        stability: 'stable' as const,
        rhymeScheme: 'A',
        rhymeConnections: [],
        averageSyllables: 2,
        lineVariance: 0,
      },
    ],
    overallStability: 'stable' as const,
    dominantRhymeScheme: 'A',
    clicheDetections: [],
  }

  beforeEach(() => {
    jest.clearAllMocks()
    ;(prosodyUtils.analyzeProsody as jest.Mock).mockReturnValue(mockAnalysisResult)
  })

  it('should analyze text and return results', async () => {
    const { result } = renderHook(() =>
      useProsodyAnalysis({
        text: 'Test line',
      })
    )

    await waitFor(() => {
      expect(result.current.analysis).toEqual(mockAnalysisResult)
      expect(result.current.isAnalyzing).toBe(false)
    })

    expect(prosodyUtils.analyzeProsody).toHaveBeenCalledWith('Test line')
  })

  it('should debounce analysis calls', async () => {
    const { result, rerender } = renderHook(
      ({ text }) => useProsodyAnalysis({ text }),
      { initialProps: { text: 'Line 1' } }
    )

    // Change text multiple times rapidly
    rerender({ text: 'Line 2' })
    rerender({ text: 'Line 3' })
    rerender({ text: 'Line 4' })

    await waitFor(() => {
      expect(result.current.analysis).toBeDefined()
    })

    // Should only call once with final value due to debouncing
    expect(prosodyUtils.analyzeProsody).toHaveBeenCalledTimes(1)
    expect(prosodyUtils.analyzeProsody).toHaveBeenCalledWith('Line 4')
  })

  it('should handle empty text', async () => {
    const { result } = renderHook(() =>
      useProsodyAnalysis({
        text: '',
      })
    )

    await waitFor(() => {
      expect(result.current.analysis).toBeNull()
      expect(result.current.isAnalyzing).toBe(false)
    })

    expect(prosodyUtils.analyzeProsody).not.toHaveBeenCalled()
  })

  it('should respect settings', async () => {
    const { result } = renderHook(() =>
      useProsodyAnalysis({
        text: 'Test line',
        settings: {
          enableStabilityAnalysis: false,
          enableClicheDetection: false,
        },
      })
    )

    await waitFor(() => {
      expect(result.current.analysis).toBeDefined()
    })

    // Check that disabled features are filtered out
    expect(result.current.analysis?.lines).toHaveLength(0)
    expect(result.current.analysis?.sections).toHaveLength(0)
    expect(result.current.analysis?.clicheDetections).toHaveLength(0)
  })

  it('should call onAnalysisComplete callback', async () => {
    const onComplete = jest.fn()

    renderHook(() =>
      useProsodyAnalysis({
        text: 'Test line',
        onAnalysisComplete: onComplete,
      })
    )

    await waitFor(() => {
      expect(onComplete).toHaveBeenCalledWith(expect.objectContaining({
        overallStability: 'stable',
      }))
    })
  })

  it('should handle analysis errors', async () => {
    const consoleError = jest.spyOn(console, 'error').mockImplementation()
    ;(prosodyUtils.analyzeProsody as jest.Mock).mockImplementation(() => {
      throw new Error('Analysis failed')
    })

    const { result } = renderHook(() =>
      useProsodyAnalysis({
        text: 'Test line',
      })
    )

    await waitFor(() => {
      expect(result.current.analysis).toBeNull()
      expect(result.current.isAnalyzing).toBe(false)
    })

    expect(consoleError).toHaveBeenCalledWith('Prosody analysis error:', expect.any(Error))
    consoleError.mockRestore()
  })

  it('should provide refresh function', async () => {
    const { result } = renderHook(() =>
      useProsodyAnalysis({
        text: 'Test line',
      })
    )

    await waitFor(() => {
      expect(result.current.analysis).toBeDefined()
    })

    jest.clearAllMocks()

    act(() => {
      result.current.refreshAnalysis()
    })

    await waitFor(() => {
      expect(prosodyUtils.analyzeProsody).toHaveBeenCalledWith('Test line')
    })
  })
})

describe('useSectionAnalysis', () => {
  beforeEach(() => {
    jest.clearAllMocks()
    ;(prosodyUtils.analyzeProsody as jest.Mock).mockReturnValue({
      sections: [
        {
          name: 'Verse 1',
          lineCount: 4,
          stability: 'stable' as const,
          rhymeScheme: 'AABB',
          rhymeConnections: [],
          averageSyllables: 8,
          lineVariance: 0.5,
        },
        {
          name: 'Chorus',
          lineCount: 4,
          stability: 'mixed' as const,
          rhymeScheme: 'ABAB',
          rhymeConnections: [],
          averageSyllables: 7,
          lineVariance: 1,
        },
      ],
    })
  })

  it('should return specific section analysis', async () => {
    const { result } = renderHook(() =>
      useSectionAnalysis('Test text', 'Chorus')
    )

    await waitFor(() => {
      expect(result.current).toBeDefined()
      expect(result.current?.name).toBe('Chorus')
      expect(result.current?.rhymeScheme).toBe('ABAB')
    })
  })

  it('should fallback to first section if not found', async () => {
    const { result } = renderHook(() =>
      useSectionAnalysis('Test text', 'Bridge')
    )

    await waitFor(() => {
      expect(result.current).toBeDefined()
      expect(result.current?.name).toBe('Verse 1')
    })
  })
})

describe('useLineAnalysis', () => {
  beforeEach(() => {
    jest.clearAllMocks()
    ;(prosodyUtils.analyzeProsody as jest.Mock).mockReturnValue({
      lines: [
        {
          text: 'Single line test',
          lineNumber: 1,
          syllableCount: 4,
          endingType: 'stable' as const,
          endingWord: 'test',
          rhymeSound: 'est',
        },
      ],
    })
  })

  it('should analyze single line', async () => {
    const { result } = renderHook(() =>
      useLineAnalysis('Single line test')
    )

    await waitFor(() => {
      expect(result.current).toBeDefined()
      expect(result.current?.text).toBe('Single line test')
      expect(result.current?.endingType).toBe('stable')
    })
  })

  it('should handle empty line', async () => {
    const { result } = renderHook(() =>
      useLineAnalysis('')
    )

    await waitFor(() => {
      expect(result.current).toBeNull()
    })

    expect(prosodyUtils.analyzeProsody).not.toHaveBeenCalled()
  })

  it('should update when line changes', async () => {
    const { result, rerender } = renderHook(
      ({ line }) => useLineAnalysis(line),
      { initialProps: { line: 'First line' } }
    )

    await waitFor(() => {
      expect(result.current).toBeDefined()
    })

    ;(prosodyUtils.analyzeProsody as jest.Mock).mockReturnValue({
      lines: [
        {
          text: 'Second line',
          lineNumber: 1,
          syllableCount: 3,
          endingType: 'unstable' as const,
          endingWord: 'line',
          rhymeSound: 'ine',
        },
      ],
    })

    rerender({ line: 'Second line' })

    await waitFor(() => {
      expect(result.current?.text).toBe('Second line')
      expect(result.current?.endingType).toBe('unstable')
    })
  })
})

describe('useProsodySettings', () => {
  it('should return default settings', () => {
    const { result } = renderHook(() => useProsodySettings())

    expect(result.current.settings).toEqual({
      enableStabilityAnalysis: true,
      enableRhymeDetection: true,
      enableClicheDetection: true,
      analysisDelay: 500,
    })
  })

  it('should provide update function', () => {
    const consoleLog = jest.spyOn(console, 'log').mockImplementation()
    const { result } = renderHook(() => useProsodySettings())

    act(() => {
      result.current.updateSettings({
        enableStabilityAnalysis: false,
        analysisDelay: 1000,
      })
    })

    expect(consoleLog).toHaveBeenCalledWith('Updating prosody settings:', {
      enableStabilityAnalysis: false,
      analysisDelay: 1000,
    })

    consoleLog.mockRestore()
  })
})
